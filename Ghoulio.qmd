---
self-contained: true
editor: 
  markdown: 
    wrap: 72
format: 
  html:
    css: styles.css
    code-fold: true
    toc: true
    toc-depth: 2
---


<style>
  .halloween-header {
    background-color: #FF6600; /* Bright Orange */
    color: #000000; /* Black text */
    padding: 15px; /* Slightly smaller padding */
    text-align: center;
    /* Changed to a non-bold font family */
    font-family: Arial, sans-serif; 
    border-bottom: 5px solid #000000;
    margin-bottom: 20px;
  }
  .halloween-header h1 {
    margin: 0;
    /* Reduced font size */
    font-size: 1.8em; 
    /* Remove the strong weight often associated with h1 */
    font-weight: normal; 
    text-transform: none; /* Keep original casing */
    letter-spacing: 1px;
  }
</style>

<div class="halloween-header">
  <h1>Safety & Risk's Password Calculator</h1>
</div>


Did you know?

Hackers are able to write scripts that can try up to 1 billion passwords per second?

This is why password strength is so important! Strong passwords containing upper and lower case letters, numbers, and special characters will be nearly impossible fro hackers to guess.

$$
Possibilities = PossibleCharacters^{Password Length}
$$

```{r,include=FALSE}
# Load necessary libraries
library(crosstalk)
library(plotly)
library(DT)
library(dplyr)
library(fresh)
library(lubridate)
library(tidyr)
library(htmltools)

knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

```{r}
# --- Define constants globally for the calculation block ---
SECONDS_PER_YEAR <- 60 * 60 * 24 * 365.25
ATTEMPTS_PER_SECOND <- 1e9 
# Define the threshold for switching to scientific notation (1 trillion)
SCIENTIFIC_THRESHOLD <- 1e12 

# --- CORE LOGIC FUNCTION ---
calculate_crack_time_raw <- function(length, use_lower, use_upper, use_numbers, use_special) {
  alphabet_size <- 0
  if (use_lower) { alphabet_size <- alphabet_size + 26 }
  if (use_upper) { alphabet_size <- alphabet_size + 26 }
  if (use_numbers) { alphabet_size <- alphabet_size + 10 }
  if (use_special) { alphabet_size <- alphabet_size + 33 }
  if (alphabet_size == 0) { return(NA) }

  log10_combinations <- length * log10(alphabet_size)
  log10_rate <- log10(ATTEMPTS_PER_SECOND) + log10(SECONDS_PER_YEAR)
  log10_crack_years <- log10_combinations - log10_rate
  
  return(10^log10_crack_years)
}

# --- 1. GENERATE ALL SCENARIOS (L=TRUE enforced) ---
lengths <- 4:32
sets <- expand_grid(
  L = c(TRUE), U = c(TRUE, FALSE), N = c(TRUE, FALSE), S = c(TRUE, FALSE)
) %>%
  mutate(
    Char_Set = paste0(if_else(L, "L", ""), if_else(U, "U", ""), if_else(N, "N", ""), if_else(S, "S", "")),
    Char_Desc = case_when(
      Char_Set == "L" ~ "Lowercase Only (26)",
      Char_Set == "LUNS" ~ "All Four (95)",
      .default = paste0("Custom (", 26*L + 26*U + 10*N + 33*S, " chars)")
    )
  )

# --- 2. COMBINE AND CALCULATE & SORT ---
full_data <- sets %>%
  tidyr::expand_grid(Length = lengths) %>%
  rowwise() %>%
  # STEP 1: Calculate Crack_Years and Alphabet_Size
  mutate(
    Crack_Years = calculate_crack_time_raw(Length, L, U, N, S),
    Alphabet_Size = 26*L + 26*U + 10*N + 33*S
  ) %>%
  # STEP 2: Calculate Combinations and Formatted_Time
  mutate(
    Combinations_Raw = round(10^(Length * log10(Alphabet_Size)), 0),
    
    # Conditional formatting for Combinations
    Combinations = if_else(
      Combinations_Raw >= SCIENTIFIC_THRESHOLD,
      format(Combinations_Raw, scientific = TRUE, digits = 3),
      format(Combinations_Raw, big.mark = ",", trim = TRUE, scientific = FALSE)
    ),
    
    # Conditional formatting for Time
    Formatted_Time = if_else(
      Crack_Years >= SCIENTIFIC_THRESHOLD,
      paste0(format(Crack_Years, scientific = TRUE, digits = 3), " years"),
      paste0(format(Crack_Years, big.mark = ",", trim = TRUE, scientific = FALSE, digits = 3), " years")
    )
  ) %>%
  ungroup() %>%
  filter(Alphabet_Size > 0) %>%
  
  # Filter the data to the desired default state (Length >= 6, U=FALSE, N=FALSE, S=FALSE)
  filter(
    Length >= 6,
    U == FALSE,
    N == FALSE,
    S == FALSE
  ) %>%
  
  # Select columns and perform the required renames first
  select(Formatted_Time, Combinations, Length, U, N, S) %>%
  
  # CRITICAL: Rename Length and the boolean flags (U, N, S)
  rename(
    "Password Length" = Length,
    "Uppercase" = U,
    "Numbers" = N,
    "Special Characters" = S
  ) %>%
  
  # Final rename for the output fields
  rename(
    "Years to Crack Password" = Formatted_Time,
    "Password Combinations" = Combinations
  )
  
# --- 3. CREATE SHARED DATA OBJECT ---
# The shared_data object only contains the pre-filtered set
shared_data <- SharedData$new(full_data)

# Create the placeholder for the initial default filter values (Length = 6)
# Note: The 'Password Length' column is now being filtered here.
default_filter_data <- full_data %>%
  filter(`Password Length` == 6)

```

```{r}
# --- INPUT 1: Password Length (SLIDER) ---
filter_slider(
  id = "length_slider", 
  label = "1. Select Password Length:", 
  sharedData = shared_data, 
  # CRITICAL FIX: Use the new column name, enclosed in backticks
  column = ~`Password Length` 
)

```





```{r,include=TRUE,echo=FALSE}
# Display the entire shared data without complex styling or column hiding
datatable(
  shared_data, 
  options = list(
    pageLength = 5, # Show 5 rows for testing
    dom = 't'       # Still hides controls, but shows more of the table
  )
)
```


