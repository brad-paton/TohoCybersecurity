---
self-contained: true
editor: 
  markdown: 
    wrap: 72
format: 
  html:
    css: styles.css
    code-fold: true
    toc: false
    toc-depth: 2
---


<style>
  .halloween-header {
    background-color: #FF6600; /* Bright Orange */
    color: #000000; /* Black text */
    padding: 15px; /* Slightly smaller padding */
    text-align: center;
    font-family: Arial, sans-serif; 
    border-bottom: 5px solid #000000;
    margin-bottom: 20px;
  }
  .halloween-header h1 {
    margin: 0;
    font-size: 1.8em; 
    font-weight: normal; 
    text-transform: none; 
    letter-spacing: 1px;
  }
</style>

<div class="halloween-header">
  <h1>ðŸŽƒ Safety & Risk's Sp00ky Password Calculator ðŸ‘»</h1>
</div>




**Did you know?**
A hacker's script can try over 1 BILLION passwords per SECOND ($10^9$ guesses)! It sounds like a lot, but with the right password they'll never get into your accounts! 

## The Exponential Math of Security

Your password strength grows exponentially. Every character you add drastically increases the time required to crack your password. 

The formula below shows how the number of password possibilities increases exponentially with the number of characters.

$$
Possibilities = PossibleCharacters^{Password Length}
$$

## How long would it take hackers to crack your password

1. Weak (Lowercase Only): The bare minimum security. (26 characters)

2. Stronger (but not strong enough!) (L + Uppercase): Doubles the available character pool. (52 characters)

3. Standard Practice (L + U + Numbers): The minimum baseline for complexity. (62 characters)

4. The Ultimate Password (All Four Sets): The absolute maximum defense. (95 characters)

## Try it Out!
Use the slider below to see the immense jump in security provided by the four character set levels:

Aim to create passwords that will take millions, or even billions of years to crack even if hackers are trying billions of possibilitis per second.

```{r,include=FALSE}
# Load necessary libraries
library(crosstalk)
library(plotly)
library(DT)
library(dplyr)
library(fresh)
library(lubridate)
library(tidyr)
library(htmltools)

knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
```

```{r}
# --- Define constants globally for the calculation block ---
SECONDS_PER_YEAR <- 60 * 60 * 24 * 365.25
ATTEMPTS_PER_SECOND <- 1e9 
SCIENTIFIC_THRESHOLD <- 1e12 
# Define the shared group name
SHARED_GROUP_ID <- "password_analysis" # Re-defined here to be used in SharedData$new()

# --- CORE LOGIC FUNCTION ---
calculate_crack_time_raw <- function(length, use_lower, use_upper, use_numbers, use_special) {
  alphabet_size <- 0
  if (use_lower) { alphabet_size <- alphabet_size + 26 }
  if (use_upper) { alphabet_size <- alphabet_size + 26 }
  if (use_numbers) { alphabet_size <- alphabet_size + 10 }
  if (use_special) { alphabet_size <- alphabet_size + 33 }
  if (alphabet_size == 0) { return(NA) }

  log10_combinations <- length * log10(alphabet_size)
  log10_rate <- log10(ATTEMPTS_PER_SECOND) + log10(SECONDS_PER_YEAR)
  log10_crack_years <- log10_combinations - log10_rate
  
  return(10^log10_crack_years)
}

# --- 1. GENERATE ALL SCENARIOS (L=TRUE enforced) ---
lengths <- 4:32
sets <- expand_grid(
  L = c(TRUE), U = c(TRUE, FALSE), N = c(TRUE, FALSE), S = c(TRUE, FALSE)
) %>%
  mutate(
    Char_Set = paste0(if_else(L, "L", ""), if_else(U, "U", ""), if_else(N, "N", ""), if_else(S, "S", "")),
    Char_Desc = case_when(
      Char_Set == "L" ~ "Lowercase Only (26)",
      Char_Set == "LUNS" ~ "All Four (95)",
      .default = paste0("Custom (", 26*L + 26*U + 10*N + 33*S, " chars)")
    )
  )

# --- 2. COMBINE AND CALCULATE & SORT ---
full_data_raw <- sets %>%
  tidyr::expand_grid(Length = lengths) %>%
  rowwise() %>%
  mutate(
    Crack_Years = calculate_crack_time_raw(Length, L, U, N, S),
    Alphabet_Size = 26*L + 26*U + 10*N + 33*S
  ) %>%
  mutate(
    Combinations_Raw = round(10^(Length * log10(Alphabet_Size)), 0),
    
    # Conditional formatting for Combinations
    Combinations = if_else(
      Combinations_Raw >= SCIENTIFIC_THRESHOLD,
      format(Combinations_Raw, scientific = TRUE, digits = 3),
      format(Combinations_Raw, big.mark = ",", trim = TRUE, scientific = FALSE)
    ),
    
    # Conditional formatting for Time
    Formatted_Time = if_else(
      Crack_Years >= SCIENTIFIC_THRESHOLD,
      paste0(format(Crack_Years, scientific = TRUE, digits = 3), " years"),
      paste0(format(Crack_Years, big.mark = ",", trim = TRUE, scientific = FALSE, digits = 3), " years")
    )
  ) %>%
  ungroup() %>%
  filter(Alphabet_Size > 0) %>%
  
  # Filter the length to set the minimum default value of 6.
  filter(Length >= 6) %>%
  
  # Select final columns and rename
  select(Formatted_Time, Combinations, Length, U, N, S) %>%
  rename(
    "Password Length" = Length,
    "Uppercase" = U,
    "Numbers" = N,
    "Special Characters" = S,
    "Years to Crack Password" = Formatted_Time,
    "Password Combinations" = Combinations
  )

# --- 3. CREATE FOUR SEPARATE SHARED DATA OBJECTS, ALL WITH THE SAME GROUP ID ---

COLUMNS_TO_KEEP <- c("Password Length", "Password Combinations", "Years to Crack Password")

# 1. Lowercase Only (L)
data_L <- full_data_raw %>% 
  filter(Uppercase == FALSE, Numbers == FALSE, `Special Characters` == FALSE) %>%
  select(all_of(COLUMNS_TO_KEEP))
shared_data_L <- SharedData$new(data_L, group = SHARED_GROUP_ID) # Group set here

# 2. Lowercase + Uppercase (L + U)
data_LU <- full_data_raw %>% 
  filter(Uppercase == TRUE, Numbers == FALSE, `Special Characters` == FALSE) %>%
  select(all_of(COLUMNS_TO_KEEP))
shared_data_LU <- SharedData$new(data_LU, group = SHARED_GROUP_ID) # Group set here

# 3. L + U + Numbers (L + U + N)
data_LUN <- full_data_raw %>% 
  filter(Uppercase == TRUE, Numbers == TRUE, `Special Characters` == FALSE) %>%
  select(all_of(COLUMNS_TO_KEEP))
shared_data_LUN <- SharedData$new(data_LUN, group = SHARED_GROUP_ID) # Group set here

# 4. All Four Sets (L + U + N + S)
data_LUNS <- full_data_raw %>% 
  filter(Uppercase == TRUE, Numbers == TRUE, `Special Characters` == TRUE) %>%
  select(all_of(COLUMNS_TO_KEEP))
shared_data_LUNS <- SharedData$new(data_LUNS, group = SHARED_GROUP_ID) # Group set here

# Create the placeholder for the initial default filter (Length = 6)
default_filter_data <- data_L %>%
  filter(`Password Length` == 6)

```


```{r}
# --- INPUT 1: Password Length (SINGLE SLIDER) ---
# Attached to shared_data_L, but controls all four tables via the shared group ID.
filter_slider(
  id = "length_slider", 
  label = "1. Select Password Length:", 
  sharedData = shared_data_L, 
  column = ~`Password Length`
  # CRITICAL: Removed the problematic 'group = ...' argument.
)
```



```{r,include=TRUE,echo=FALSE}


# --- TABLE 1: LOWERCASE ONLY (L) ---
htmltools::tags$h4("1. Lowercase Only (a-z) | Alphabet Size: 26")

datatable(
  shared_data_L, 
  options = list(
    pageLength = 1, # Show 5 rows for testing
    dom = 't'       # Still hides controls, but shows more of the table
  )
)

# --- TABLE 2: LOWERCASE + UPPERCASE (L + U) ---
htmltools::tags$h4("2. Lowercase + Uppercase (A-Z, a-z) | Alphabet Size: 52")

datatable(
  shared_data_LU, 
  options = list(
    pageLength = 1, # Show 5 rows for testing
    dom = 't'       # Still hides controls, but shows more of the table
  )
)

# --- TABLE 3: L + U + NUMBERS (L + U + N) ---
htmltools::tags$h4("3. L + U + Numbers (0-9) | Alphabet Size: 62")

datatable(
  shared_data_LUN, 
  options = list(
    pageLength = 1, # Show 5 rows for testing
    dom = 't'       # Still hides controls, but shows more of the table
  )
)

# --- TABLE 4: ALL FOUR SETS (L + U + N + S) ---
htmltools::tags$h4("4. All Four Sets (+ Special Chars) | Alphabet Size: 95")

datatable(
  shared_data_LUNS, 
  options = list(
    pageLength = 1, # Show 5 rows for testing
    dom = 't'       # Still hides controls, but shows more of the table
  )
)

```


